<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet-0.7/leaflet.css" />
    <script src="http://d3js.org/d3.v3.min.js" type="text/javascript"></script>
    <script src="http://cdn.leafletjs.com/leaflet-0.7/leaflet.js"></script>
    <script src='https://api.tiles.mapbox.com/mapbox.js/v1.6.4/mapbox.js'></script>
    <link href='https://api.tiles.mapbox.com/mapbox.js/v1.6.4/mapbox.css' rel='stylesheet' />
	
<style>
		html,
		body {
			height: 100%;
			width: 100%;
		}
		body {
			margin: 0;
		}
		#map {
			width: 100%;
			height: 100%;
		}
		svg {
			position: relative;
		}
		path {
			fill: yellow;
			stroke-width: 2px;
			stroke: red;
			stroke-opacity: 1;
		}
		.travelMarker {
			fill: yellow;
			opacity: 0.75;
		}
		.waypoints {
			fill: red;
			opacity: 1;
		}
		
		
		.areaChart {
			position: absolute;
			bottom: 0;
			background: #fff;
			opacity: 0.6;
		}
		
		.axis path,
		.axis line {
			fill: none;
			stroke: #000;
			shape-rendering: crispEdges;
			stroke-width:1;
		}
		
		.axis text {
			stroke: black;
		}

	.lineConnect {
		fill: none;
		stroke: blue;
		opacity: 1;
	}
	.locnames {
		fill: white;
		text-shadow: 1px 1px 1px #FFF, 3px 3px 5px #000;
		font-weight: bold;
		font-size: 13px;
	}
    </style>
</head>
<body>
	<div id="demo"></div>
	<div id="map"></div>
		<script type="text/javascript">
// 		'http://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png

			var mapboxTiles = L.tileLayer('https://api.mapbox.com/v4/mapbox.run-bike-hike/{z}/{x}/{y}.png?access_token={token}', {
       			attribution: '<a href="http://www.mapbox.com/about/maps/" target="_blank">Terms &amp; Feedback</a>',
       			token: 'pk.eyJ1IjoiZHJld3N0aWxlcyIsImEiOiJjaWw2YXR4eXgwMWl6dWhsdjhrZGxuMXBqIn0.4rYaU8tPJ9Mw2bniPfAKdQ'
    		});
     
			var map = L.map('map')
				.addLayer(mapboxTiles)
				.setView([34.00756196861457, -118.49982261657716], 15);
							
			var svg = d3.select(map.getPanes().overlayPane).append("svg");
			var g = svg.append("g").attr("class", "leaflet-zoom-hide");
			
			
			/*
			 * Chart
			 */
			 
			 var margin = { top: 20, right: 20, bottom: 30, left: 50 };
			 var areaChartWidth = window.innerWidth;
			 var areaChartHeight = 200;
			 
			 var x = d3.scale.linear()
			 	.range([0, areaChartWidth]);
			 	
			 var y = d3.scale.linear()
			 	.range([areaChartHeight, 0]);
			 	
			 var xAxis = d3.svg.axis()
			 	.scale(x)
			 	.orient("bottom");
			 	
			var yAxis = d3.svg.axis()
				.scale(y)
				.orient("left");
				
			var area = d3.svg.area()
				.x(function(d) {return x(d.time); })
				.y0(areaChartHeight)
				.y1(function(d) { return y(d.heart); });
				
			var areaChartSvg = d3.select("body").append("svg")
				.attr("width", areaChartWidth + margin.left + margin.right)
				.attr("height", areaChartHeight + margin.top + margin.bottom)
				.attr("class", "areaChart")
				.append("g")
				.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
				
				var dummyData = [];
				 
				x.domain([0, 241]);
				y.domain([40, 220]);
				
				var chartPath = areaChartSvg.append("path")
					.datum(dummyData)
					.attr("class", "area");
					
				areaChartSvg.append("g")
					.attr("class", "x axis")
					.attr("transform", "translate(0," + areaChartHeight + ")")
					.call(xAxis);
					
				areaChartSvg.append("g")
					.attr("class", "y axis")
					.call(yAxis)
					.append("text")
					.attr("transform", "rotate(-90)")
					.attr("y", 6)
					.attr("dy", "0.71em")
					.style("text-anchor", "end")
					.text("Heart Rate (BPM)");
					
			
			var queue = [];
			
			var currentPoint = 0;
						var time = 0;
			d3.json("la_out.json", function(collection) {
				
				var featuresdata = collection.features;
				mapCoordinatesToView(featuresdata);
				
				var transform = d3.geo.transform({ point: projectPoint });
				var d3path = d3.geo.path().projection(transform);
				
				
				var toLine = d3.svg.line()
					.interpolate("linear")
					.x(function(d) {
						return applyLatLngToLayer(d).x
					})
					.y(function(d) {
						return applyLatLngToLayer(d).y
					});
					
				var ptFeatures = g.selectAll("circle")
					.data(featuresdata)
					.enter()
					.append("circle")
					.attr("r", 3)
					.attr("class", function(d) {
						return "waypoints " + "c" + d.properties.time
					})
					.style("opacity", 0);
				
				
				var linePath = g.selectAll(".lineConnect")
					.data([featuresdata])
					.enter()
					.append("path")
					.attr("class", "lineConnect");
			
				var marker = g.append("circle")
					.attr("r", 10)
					.attr("id", "marker")
					.attr("class", "travelMarker");
			
// 			map.on("viewreset", reset);
			
			reset();
			
			var precision = 10000;
			var minHeart = 12;
			var maxHeart = 8;
			var heartRate = 600;
			conversion();
			heartBeatUp();
			function conversion() {
				var l = linePath.node().getTotalLength();
				for (var i = 1; i <= precision; i++) {
					var t = i / precision;
					var p = linePath.node().getPointAtLength(t * l);
					queue.push(p);
				}
				
				currentPoint = 0;
				for (var i = 0; i < queue.length; i++) {
					assignDrawTime(queue[i]);
				}
				
				currentPoint = 0;
				
				console.log(queue);
				
				while (queue.length > 0) {
					animatePoints(queue.shift());
				}
			}
			
			function assignDrawTime(p) {
			// highest = 32
			// lowest = 5
console.log(currentPoint);
			var dp = featuresdata[currentPoint].properties;
				if (Math.abs(dp.x - p.x) <=2 && Math.abs(dp.y - p.y) <= 2) {
					if (currentPoint != 239) currentPoint++;
				}
				else {
					
				}
				
				p.t = calculateDrawTimeFromSpeed(dp.speed);
				p.s = dp.speed;
				
			}
			

			function calculateDrawTimeFromSpeed(speed) {
				
				if (speed < 10) {
					time += 60;
				}
				else if (speed < 15) {
					time += 45;
				}
				else if (speed < 20) {
					time += 30
				}
				else {
					time += 15;
				} 
				
				return time;
			}
						

			
			function reset() {
				var bounds = d3path.bounds(collection),
					topLeft = bounds[0],
					bottomRight = bounds[1];
					
				ptFeatures.attr("transform",
					function(d) {
						return "translate(" + 
							applyLatLngToLayer(d).x + "," +
							applyLatLngToLayer(d).y + ")";
					});
					
				marker.attr("transform",
					function() {
						var y = featuresdata[0].geometry.coordinates[1];
						var x = featuresdata[0].geometry.coordinates[0];
						return "translate(" + 
							map.latLngToLayerPoint(new L.LatLng(y, x)).x + "," + 
							map.latLngToLayerPoint(new L.LatLng(y, x)).y + ")";
				})
			
				svg.attr("width", bottomRight[0] - topLeft[0] + 120)
					.attr("height", bottomRight[1] - topLeft[1] + 120)
					.style("left", topLeft[0] - 50 + "px")
					.style("top", topLeft[1] - 50 + "px");
				
				linePath.attr("d", toLine);
				g.attr("transform", "translate(" + (-topLeft[0] + 50) + ","
					+ (-topLeft[1] + 50) + ")");
				}
				

				function projectPoint(x, y)	{
					var point = map.latLngToLayerPoint(new L.LatLng(y, x));
					this.stream.point(point.x, point.y);
				}
				
				function showPoint(p) {
					
						var dp = featuresdata[currentPoint].properties;
						if (Math.abs(dp.x - p.x) <= 5 && Math.abs(dp.y - p.y) <= 5) {
							dummyData.push({
								"time": i++,
								"heart": dp.heart
							});
							d3.select(".c" + currentPoint).style("opacity", 1);
							chartPath.attr("d", area);
							currentPoint++;
						

						}
						else {
						// wait for match
					}
				}
				
				var oldTime = null;
				var i = 0;
				
					function heartBeatUp() {
						marker.transition().duration(heartRate).attr("r", maxHeart).each("end", heartBeatDown);
					}
					
					var beat = false;
					function heartBeatDown() {
						if (beat) {
							beat = !beat;
							marker.transition().duration(heartRate).attr("r", minHeart).each("end", heartBeatDown);
						}
						else {
							marker.transition().duration(heartRate).attr("r", minHeart).each("end", heartBeatUp);
						}
					}	
						
			function animatePoints(p) {
				setTimeout(function() {
					marker.attr("transform", "translate(" + p.x + "," + p.y + ")");
					
					var rate = getRate(p.s);
					if (toggle++ % rate == 0) {
	                    var focus = map.layerPointToLatLng(new L.Point(p.x, p.y));
						map.panTo(focus);
						showPoint(p);
					}
					
				}, p.t);
			}

			
			
			
		function getRate(s) {
			if (s < 10) {
				return 5;
			}
			else {
				 return 2;
				}

		}
			
			function mapCoordinatesToView(data) {
				for (var i = 0; i < data.length; i++) {
					var coordinates = applyLatLngToLayer(data[i]);
					
					data[i].properties.x = coordinates.x;
					data[i].properties.y = coordinates.y;
				}
			}
			
			 							var points = [];
				
			var toggle = 0;
					
					
			function applyLatLngToLayer(d) {
				var y = d.geometry.coordinates[1]
				var x = d.geometry.coordinates[0];
				return map.latLngToLayerPoint(new L.LatLng(y, x))
			}
		});
    	</script>
</body>
</html>